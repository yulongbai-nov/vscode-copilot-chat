/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { RequestType } from '@vscode/copilot-api';
import { ChatFetchResponseType, ChatLocation } from '../../../platform/chat/common/commonTypes';
import { ConfigKey, IConfigurationService } from '../../../platform/configuration/common/configurationService';
import { ChatEndpoint } from '../../../platform/endpoint/node/chatEndpoint';
import { NextCursorLinePrediction } from '../../../platform/inlineEdits/common/dataTypes/nextCursorLinePrediction';
import { OptionalChatRequestParams } from '../../../platform/networking/common/fetch';
import { IExperimentationService } from '../../../platform/telemetry/common/nullExperimentationService';
import { fromUnknown } from '../../../util/common/errors';
import { Result } from '../../../util/common/result';
import { TokenizerType } from '../../../util/common/tokenizer';
import { ITracer } from '../../../util/common/tracing';
import { assertNever } from '../../../util/vs/base/common/assert';
import { CancellationToken } from '../../../util/vs/base/common/cancellation';
import { IInstantiationService } from '../../../util/vs/platform/instantiation/common/instantiation';
import { constructTaggedFile, getUserPrompt, PromptPieces } from '../common/promptCrafting';
import { constructMessages } from './xtabUtils';

export class XtabNextCursorPredictor {

	private isDisabled: boolean;

	constructor(
		private readonly computeTokens: (text: string) => number,
		@IInstantiationService private readonly instaService: IInstantiationService,
		@IConfigurationService private readonly configService: IConfigurationService,
		@IExperimentationService private readonly expService: IExperimentationService,
	) {
		this.isDisabled = false;
	}

	public determineEnablement(): NextCursorLinePrediction | undefined {
		if (this.isDisabled) {
			return undefined;
		}

		const originalNextCursorLinePrediction = this.configService.getExperimentBasedConfig(ConfigKey.TeamInternal.InlineEditsNextCursorPredictionEnabled, this.expService);

		switch (originalNextCursorLinePrediction) {
			case NextCursorLinePrediction.OnlyWithEdit:
			case NextCursorLinePrediction.Jump:
			case undefined:
				return originalNextCursorLinePrediction;

			// remove support for LabelOnlyWithEdit
			case NextCursorLinePrediction.LabelOnlyWithEdit:
				return NextCursorLinePrediction.OnlyWithEdit;

			// for backward compatibility
			case true:
				return NextCursorLinePrediction.OnlyWithEdit;
			case false:
				return undefined;
			default:
				assertNever(originalNextCursorLinePrediction);
		}
	}


	public async predictNextCursorPosition(promptPieces: PromptPieces, parentTracer: ITracer): Promise<Result</* zero-based line number */ number, Error>> {

		const tracer = parentTracer.sub('predictNextCursorPosition');

		const systemMessage = `Your task is to predict the next line number in the current file where the developer is most likely to make their next edit, using the provided context. If you don't think anywhere is a good next line jump target, just output the current line number of the cursor. Make sure to just output the line number and nothing else (no explanation, reasoning, etc.).`;

		const maxTokens = this.configService.getExperimentBasedConfig(ConfigKey.Advanced.InlineEditsNextCursorPredictionCurrentFileMaxTokens, this.expService);

		const currentFileContentR = constructTaggedFile(
			promptPieces.currentDocument,
			promptPieces.editWindowLinesRange,
			promptPieces.areaAroundEditWindowLinesRange,
			{
				...promptPieces.opts,
				currentFile: {
					...promptPieces.opts.currentFile,
					maxTokens,
					includeTags: false,
				}
			},
			this.computeTokens,
			{ includeLineNumbers: { areaAroundCodeToEdit: false, currentFileContent: true } }
		);

		if (currentFileContentR.isError()) {
			tracer.trace(`Failed to construct tagged file: ${currentFileContentR.err}`);
			return Result.fromString(currentFileContentR.err);
		}

		const { taggedCurrentDocLines, areaAroundCodeToEdit } = currentFileContentR.val;

		const newPromptPieces = new PromptPieces(
			promptPieces.currentDocument,
			promptPieces.editWindowLinesRange,
			promptPieces.areaAroundEditWindowLinesRange,
			promptPieces.activeDoc,
			promptPieces.xtabHistory,
			taggedCurrentDocLines,
			areaAroundCodeToEdit,
			promptPieces.langCtx,
			promptPieces.aggressivenessLevel,
			this.computeTokens,
			{
				...promptPieces.opts,
				includePostScript: false,
			}
		);

		const userMessage = getUserPrompt(newPromptPieces);

		const messages = constructMessages({
			systemMsg: systemMessage,
			userMsg: userMessage
		});

		const modelName = this.configService.getExperimentBasedConfig(ConfigKey.TeamInternal.InlineEditsNextCursorPredictionModelName, this.expService);
		if (modelName === undefined) {
			tracer.trace('Model name for cursor prediction is not defined; skipping prediction');
			return Result.fromString('modelNameNotDefined');
		}

		const url = this.configService.getConfig(ConfigKey.TeamInternal.InlineEditsNextCursorPredictionUrl);
		const secretKey = this.configService.getConfig(ConfigKey.TeamInternal.InlineEditsNextCursorPredictionApiKey);

		const endpoint = this.instaService.createInstance(ChatEndpoint, {
			id: modelName,
			name: 'nes.nextCursorPosition',
			urlOrRequestMetadata: url ? url : { type: RequestType.ProxyChatCompletions },
			model_picker_enabled: false,
			is_chat_default: false,
			is_chat_fallback: false,
			version: '',
			capabilities: {
				type: 'chat',
				family: '',
				tokenizer: TokenizerType.CL100K,
				limits: undefined,
				supports: {
					parallel_tool_calls: false,
					tool_calls: false,
					streaming: true,
					vision: false,
					prediction: false,
					thinking: false
				}
			},
		});

		const maxResponseTokens = this.configService.getExperimentBasedConfig(ConfigKey.TeamInternal.InlineEditsNextCursorPredictionMaxResponseTokens, this.expService);

		let requestOptions: OptionalChatRequestParams = {
			max_tokens: maxResponseTokens,
		};

		if (secretKey) {
			requestOptions = { ...requestOptions, secretKey };
		}

		const response = await endpoint.makeChatRequest2(
			{
				messages,
				debugName: 'nes.nextCursorPosition',
				finishedCb: undefined,
				location: ChatLocation.Other,
				requestOptions,
			},
			CancellationToken.None,
		);

		if (response.type !== ChatFetchResponseType.Success) {
			if (response.type === ChatFetchResponseType.NotFound) {
				tracer.trace('Next cursor position prediction endpoint not found; disabling predictor for current session.');
				this.isDisabled = true;
			}
			return Result.fromString(`fetchError:${response.type}`);
		}

		try {
			const trimmed = response.value.trim();
			const lineNumber = parseInt(trimmed, 10);
			if (isNaN(lineNumber)) {
				return Result.fromString(`gotNaN`);
			}
			if (lineNumber < 0) {
				return Result.fromString(`negativeLineNumber`);
			}

			return Result.ok(lineNumber);
		} catch (err: unknown) {
			tracer.trace(`Failed to parse predicted line number from response '${response.value}': ${err}`);
			return Result.fromString(`failedToParseLine:"${response.value}". Error ${fromUnknown(err).message}`);
		}
	}
}
